input:
    input.go: |
        package structs

        // goverter:converter
        type Default interface {
            // goverter:update target
            Convert(source Input, target *Output)
        }

        // goverter:converter
        type IgnoreBasic interface {
            // goverter:update target
            // goverter:update:ignoreZeroValueField:basic
            Convert(source Input, target *Output)
        }

        // goverter:converter
        type IgnoreStruct interface {
            // goverter:update target
            // goverter:update:ignoreZeroValueField:struct
            Convert(source Input, target *Output)
        }

        type Input struct {
            A string
            A2 ID
            B bool
            C int
            C2 int64
            D complex64
            E struct{Name string}
            N Nested

            S *string
            I *int
        }
        type Output struct {
            A string
            A2 ID
            B bool
            C int
            C2 int64
            D complex64
            E struct{Name string}
            N Nested

            S *string
            I *int
        }
        type ID string
        type Nested struct {
            Name string
        }
success:
    - generated/generated.go: |
        // Code generated by github.com/jmattheis/goverter, DO NOT EDIT.

        package generated

        import execution "github.com/jmattheis/goverter/execution"

        type DefaultImpl struct{}

        func (c *DefaultImpl) Convert(source execution.Input, target *execution.Output) {
        	target.A = source.A
        	target.A2 = execution.ID(source.A2)
        	target.B = source.B
        	target.C = source.C
        	target.C2 = source.C2
        	target.D = source.D
        	var unnamed struct {
        		Name string
        	}
        	unnamed.Name = source.E.Name
        	target.E = unnamed
        	target.N = c.structsNestedToStructsNested(source.N)
        	if source.S != nil {
        		xstring := *source.S
        		target.S = &xstring
        	}
        	if source.I != nil {
        		xint := *source.I
        		target.I = &xint
        	}
        }
        func (c *DefaultImpl) structsNestedToStructsNested(source execution.Nested) execution.Nested {
        	var structsNested execution.Nested
        	structsNested.Name = source.Name
        	return structsNested
        }

        type IgnoreBasicImpl struct{}

        func (c *IgnoreBasicImpl) Convert(source execution.Input, target *execution.Output) {
        	if source.A != "" {
        		target.A = source.A
        	}
        	if source.A2 != "" {
        		target.A2 = execution.ID(source.A2)
        	}
        	if source.B != false {
        		target.B = source.B
        	}
        	if source.C != 0 {
        		target.C = source.C
        	}
        	if source.C2 != 0 {
        		target.C2 = source.C2
        	}
        	if source.D != 0 {
        		target.D = source.D
        	}
        	var unnamed struct {
        		Name string
        	}
        	if source.E.Name != "" {
        		unnamed.Name = source.E.Name
        	}
        	target.E = unnamed
        	target.N = c.structsNestedToStructsNested2(source.N)
        	if source.S != nil {
        		xstring := *source.S
        		target.S = &xstring
        	}
        	if source.I != nil {
        		xint := *source.I
        		target.I = &xint
        	}
        }
        func (c *IgnoreBasicImpl) structsNestedToStructsNested2(source execution.Nested) execution.Nested {
        	var structsNested execution.Nested
        	structsNested.Name = source.Name
        	return structsNested
        }

        type IgnoreStructImpl struct{}

        func (c *IgnoreStructImpl) Convert(source execution.Input, target *execution.Output) {
        	target.A = source.A
        	target.A2 = execution.ID(source.A2)
        	target.B = source.B
        	target.C = source.C
        	target.C2 = source.C2
        	target.D = source.D
        	if source.E != struct {
        		Name string
        	}{} {
        		var unnamed struct {
        			Name string
        		}
        		unnamed.Name = source.E.Name
        		target.E = unnamed
        	}
        	if source.N != (execution.Nested{}) {
        		target.N = c.structsNestedToStructsNested3(source.N)
        	}
        	if source.S != nil {
        		xstring := *source.S
        		target.S = &xstring
        	}
        	if source.I != nil {
        		xint := *source.I
        		target.I = &xint
        	}
        }
        func (c *IgnoreStructImpl) structsNestedToStructsNested3(source execution.Nested) execution.Nested {
        	var structsNested execution.Nested
        	structsNested.Name = source.Name
        	return structsNested
        }
